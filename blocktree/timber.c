/*************************************************************
 *							     *
 *	     Timber!  BlockTree example program		     *
 *		v1.0, 16 October 2016			     *
 *							     *
 *		(c) 2016, STFC (www.stfc.ac.uk)		     *
 *		 jens.jensen@stfc.ac.uk			     *
 *							     *
 * This program was written to explore "blocktree" checksums,*
 * as defined in RFC 6962, but used here to checksum words   *
 * read from a file rather than certificates.  It uses an    *
 * ADLER32 checksum instead of a strong hash, but the	     *
 * checksum, of course, can be replaced with a stronger one. *
 * The program thus provides append-only logging with the    *
 * peers keeping the server honest.			     *
 *************************************************************/

// This implementation requires the getline() GNU extension,
// and zlib for the implementation of the ADLER32 checksum.
//
// How to build:
// gcc -Wall -o timber timber.c -lz
//
// How to run:
// ./timber words
// where words is a file with words, one per line.  Words can
// be at most 14 characters long (words that are too long are
// ignored and the empty string is used instead.)


#include <stdlib.h>
#include <string.h>
#include <stdio.h>
// Memory requirements should not be excessive, so we 'assert' on
// mallocs (which means program will die if we run out of memory)
#include <assert.h>
#include <errno.h>
#include <sys/types.h>
// For the adler sum utility
#include <zlib.h>





// A node either has an entry or has branches (left, right - at most
// two), but should not have both.  Entry contains a word which need
// not be NUL terminated, so maximal length is 14 characters.

struct node_t {
    /** Left subtree - set for all nodes except leaf nodes (or the empty tree) */
    struct node_t *left;
    /** Right subtree */
    struct node_t *right;
    /** Checksum - generated by the cksum_tree() function */
    u_int32_t cksum;
    // The next two slots need to be allocated consecutively...
    /** base is a \000 or \001 character to prevent certain types of attacks, see RFC6962 */
    char base;
    /** entry is the word in a leaf node, NOT NUL terminated */
    char entry[14];
    /** elength is a byte containing the length of the 'entry' word, only used for leaf nodes */
    char elength;
};


// An array used to hold stuff (well, strings) - could also have
// used the GNU argz.
struct array_t {
    /** Pointer to an array of strings */
    char const **stuff;
    /** Memory allocated, i.e. maximal length of 'stuff' array */
    size_t allocsize;
    /** Memory used, i.e. number of valid strings in array */
    size_t usedsize;
};





/** \brief Checksum function
 * \param a Pointer to char (ie bytes) to be checksummed
 * \param k Size (ie number of bytes) to be checksummed
 * \param x Pointer to location where checksum is to be stored.
 */
void checksum(char const *a, size_t k, u_int32_t *x);

//! \defgroup tree ``Tree Functions''
//! @{

//! Is the node a leaf node? (will return true for empty tree, too)
int node_is_leaf(struct node_t const *);

//! Allocate a node; it is set to be an empty tree
struct node_t *alloc_node();

//! Set the word in a node from a normal string; returns 0 if successful.
int setword_node(struct node_t *, char const *);

//! Get the word out of a node, into a pre-allocated buffer of size >=15.  Returns -1 if the node is not a leaf node.
int getword_node(struct node_t const *, char *);

//! Free a node
void free_node(struct node_t *);

//! Free the whole tree
void free_tree(struct node_t *);

//! One of the two main functions - Create checksums throughout tree
void cksum_tree(struct node_t *);

//! The other main function - create the tree from an array of strings
void make_tree(struct array_t const *, struct node_t *);

//! Print a tree to a file (the last int is for indentation)
void print_tree(FILE *, struct node_t *, int);

//! Read a file into a tree, returning zero upon success (if not, it will have printed an error message)
int read_file(FILE *, struct node_t *);

//! @}
//! \defgroup array ``Array Functions''
//! @{

//! Read file into array, returning 0 upon success
int read_file_to_array(FILE *, struct array_t *);

//! Array - initialise
void init_array(struct array_t *);

//! Free array and contents
void free_array(struct array_t *);

//! push_back
void pushback_array(struct array_t *, char const *);

//! get length
// Doesn't work when declared inline...
//inline size_t get_array_size(struct array_t const *a) { a->usedsize; }
size_t get_array_size(struct array_t const *);

//! get entry at index
char const *get_array_entry(struct array_t const *, size_t);

//! @}


int
main(int argc, char **argv)
{
    // The root node needs to be allocated, because free_tree() will free it!
    struct node_t *root = alloc_node();
    FILE *fp;
    int ret;

    if(argc != 2) {
	fprintf(stderr, "Usage: %s <filename>, file containing list of words to read and turn into a tree\n", argv[0]);
	return 1;
    }

    fp = fopen(argv[1], "r");
    if(!fp) {
	fprintf(stderr, "Failed to open \"%s\" for reading: %s\n", argv[1], strerror(errno));
	return 1;
    }

    ret = read_file(fp, root);
    fclose(fp);

    if(!ret) {
	cksum_tree(root);

	print_tree(stdout, root, 0);
    }

    free_tree(root);
    return 0;
}



struct node_t *
alloc_node()
{
    // Allocating a node creates an empty tree by default
    struct node_t *p = (struct node_t *)malloc(sizeof(struct node_t));
    assert(p);
    p->left = NULL;
    p->right = NULL;
    p->base = p->elength = '\0';
    p->entry[0] = '\0';
    p->cksum = 0;
    return p;
}


void
checksum(char const *q, size_t len, u_int32_t *buf)
{
    // Calling the zlib functions for the implementation of the ADLER32 checksum
    uLong cksum = adler32(0, Z_NULL, 0);
    if(len > 0) {
	cksum = adler32(cksum, (const Bytef *)q, len);
    }
    *buf = (u_int32_t)cksum;
}


int
node_is_leaf(struct node_t const *p)
{
    // Unless the tree is empty, a node is a leaf node iff it does not
    // have a left subtree
    return p->left == NULL;
}


int
setword_node(struct node_t *p, char const *str)
{
    size_t n = strlen(str);
    if(n > 14) {
	fprintf(stderr, "Word \"%s\" too long\n", str);
	return -1;
    }
    memcpy(p->entry, str, n);
    p->base = '\0';
    p->elength = n;
    return 0;
}


int
getword_node(struct node_t const *p, char *buf)
{
    if(!node_is_leaf(p))
	return -1;
    memcpy(buf, p->entry, p->elength);
    buf[(int)(p->elength)] = '\0';
    return 0;
}


void
free_node(struct node_t *p)
{
    free(p);
    p = NULL;
}


void
free_tree(struct node_t *p)
{
    if(p->left) {
	free_tree(p->left);
	p->left = NULL;
    }
    if(p->right) {
	free_tree(p->right);
	p->right = NULL;
    }
    free_node(p);
}


void
cksum_tree(struct node_t *p) {
    if(node_is_leaf(p)) {
	// Note that the base byte is summed as well - should be NUL for a leaf
	checksum(&(p->base), p->elength+1, &(p->cksum));
    }
    else {
	int len = 1;	    /* number of bytes to checksum */
	// The left subtree must always be defined
	cksum_tree(p->left);
	if(p->right) cksum_tree(p->right);
	// set the base to value 1
	p->base = '\001';
	// copy the left checksum into the word
	memcpy(&(p->entry[0]), &(p->left->cksum), sizeof(u_int32_t));
	len += sizeof(u_int32_t);
	if(p->right) {
	    memcpy(&(p->entry[sizeof(u_int32_t)]), &(p->right->cksum), sizeof(u_int32_t));
	    len += sizeof(u_int32_t);
	}
	// ... and now checksum the node
	checksum(&(p->base), len, &(p->cksum));
    }
}


// Helper function for make_tree: find largest power of two strictly smaller than a given (positive) number
unsigned int
make_tree_cut(unsigned int k)
{
    assert(k);
    unsigned int m = 1;
    for(;;) {
	unsigned int m1 = m << 1;
	assert(m1);		/* check that we haven't overflowed */
	if(m1 >= k)
	    return m;
	m = m1;
    }
}


// Build a tree in 'tree' from array entries up from 'lower' up to but not including 'upper'
void
make_tree_sub(struct array_t const *a, struct node_t *tree, unsigned int lower, unsigned int upper)
{
    unsigned int cut;
    assert(upper > lower);
    if(upper - lower == 1) {
	// Leaf node
	setword_node(tree, get_array_entry(a, lower));
	return;
    }
    cut = lower + make_tree_cut(upper-lower);
    tree->left = alloc_node();
    make_tree_sub(a, tree->left, lower, cut);
    if(cut < upper) {
	tree->right = alloc_node();
	make_tree_sub(a, tree->right, cut, upper);
    }
}


void
make_tree(struct array_t const *a, struct node_t *tree)
{
    unsigned int cut;
    switch(get_array_size(a)) {
    case 0:
	return;
    case 1:
	setword_node(tree, get_array_entry(a, 0));
	return;
    }
    // Array size is >= 2
    cut = make_tree_cut(get_array_size(a));
    // Left subtree
    tree->left = alloc_node();
    make_tree_sub(a, tree->left, 0, cut);
    if(cut < get_array_size(a)) {
	tree->right = alloc_node();
	make_tree_sub(a, tree->right, cut, get_array_size(a));
    }
}


void
print_tree(FILE *stream, struct node_t *p, int lvl)
{
    int i;
    // Indentation
    assert(sizeof(u_int32_t) == sizeof(unsigned int));
    for(i = 0; i < lvl; ++i) fprintf(stream, "	");
    if(node_is_leaf(p)) {
	char s[16];
	getword_node(p, s);
	fprintf(stream, "%08X - %s\n", (unsigned int)p->cksum, s);
    } else {
	fprintf(stream, "%08X\n", (unsigned int)p->cksum);
	print_tree(stream, p->left, lvl+1);
	print_tree(stream, p->right, lvl+1);
    }
}


void
init_array(struct array_t *a)
{
    a->stuff = (char const **)malloc(1024 * sizeof(char const *));
    assert(a->stuff);
    a->allocsize = 256;
    a->usedsize = 0;
}


void
free_array(struct array_t *a)
{
    int i;
    for(i = 0; i < a->usedsize; ++i) {
	free((void *)((a->stuff)[i]));
	(a->stuff)[i] = NULL;
    }
    free((void *)a->stuff);
    a->stuff = NULL;
    a->allocsize = 0;
    a->usedsize = 0;
}


size_t
get_array_size(struct array_t const *a)
{
    return a->usedsize;
}


void
pushback_array(struct array_t *a, char const *s)
{
    if(a->usedsize == a->allocsize) {
	char const **f = (char const **)realloc(a->stuff, 2 * a->allocsize * sizeof(char const *));
	assert(f);
	a->stuff = f;
	// Double the size allocated for the array
	a->allocsize <<= 1;
    }
    (a->stuff)[a->usedsize] = s;
    ++(a->usedsize);
}


// get entry at index
char const *
get_array_entry(struct array_t const *a, size_t k)
{
    if(k >= a->usedsize) {
	fprintf(stderr, "Array index out of bounds - %u/%u\n", (unsigned int)k, (unsigned int)a->usedsize);
	return NULL;
    }
    return (a->stuff)[k];
}


int
read_file(FILE *fp, struct node_t *p)
{
    struct array_t a;
    int ret;

    init_array(&a);

    ret = read_file_to_array(fp, &a);

    // If make_tree returned a boolean
    // return ret || make_tree(&a, p);
    if(!ret)
	make_tree(&a, p);
    free_array(&a);
    return ret;
}



int
read_file_to_array(FILE *fp, struct array_t *a)
{
    unsigned int lineno = 0;
    size_t bufsize = 80;
    char *buf = (char *)malloc(bufsize);
    assert(buf);

    errno = 0;
    for(;;) {
	ssize_t len = getline(&buf, &bufsize, fp);
	++lineno;
	if(len < 0) {
	    if(errno != 0) {
		fprintf(stderr, "Read error at line %u: %s\n", lineno, strerror(errno));
		return -1;
	    }
	    return 0;
	}
	else if(len > 0) {
	    // Chomp the string
	    if(buf[len-1] == '\n') --len;
	    char *d = (char *)malloc(len+1);
	    assert(d);
	    d[len] = '\0';
	    memcpy(d, buf, len);
	    // Debug
	    fprintf(stderr, "Reading \"%s\"\n", d);
	    pushback_array(a, d);
	}
	else			/* len is zero */
	    break;
    }
    return 0;
}
